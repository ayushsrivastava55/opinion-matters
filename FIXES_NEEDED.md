# Arcium Integration Fixes - Complete Plan

Based on studying the blackjack example, here are all the fixes needed:

## 1. Program Macro ✅ COMPLETED
- Changed `#[program]` to `#[arcium_program]` in lib.rs

## 2. Account Struct Macros
All invocation account structs need:
```rust
#[queue_computation_accounts("encrypted_ix_name", payer)]
```

All callback account structs need:
```rust
#[callback_accounts("encrypted_ix_name")]
```

## 3. Argument Types

### Current Issues:
- Using `Argument::PlaintextBytes32()` which doesn't exist
- Using `Argument::EncryptedBool()` which may not exist
- Need to pass encrypted data correctly

### Fixes:

**For submit_private_trade.rs:**
```rust
// Current (WRONG):
Argument::EncryptedU64(ciphertext_amount),
Argument::EncryptedBool(ciphertext_side),
Argument::EncryptedU64(ciphertext_max_price),
Argument::EncryptedU64(market.yes_reserves.to_le_bytes()...),
Argument::EncryptedU64(market.no_reserves.to_le_bytes()...),
Argument::PlaintextBytes32(market.cfmm_state_commitment),

// Correct (based on blackjack pattern):
// For encrypted circuit inputs that are Enc<Shared, T>:
Argument::ArcisPubkey(pub_key),
Argument::PlaintextU128(nonce),
// Then reference the account data directly for the Market state
Argument::Account(ctx.accounts.market.key(), OFFSET_YES_RESERVES, 8),
Argument::Account(ctx.accounts.market.key(), OFFSET_NO_RESERVES, 8),
Argument::Account(ctx.accounts.market.key(), OFFSET_CFMM_COMMITMENT, 32),
```

The encrypted input (trade details) comes from the client-side encryption, and the current market state is read directly from the account using `Argument::Account()`.

## 4. Callback Output Structures

### Pattern from Blackjack:
- **Single return value**: `ComputationOutputs::Success(OutputName { field_0 })`
- **Tuple return**: `ComputationOutputs::Success(OutputName { field_0: OutputStruct0 { field_0, field_1, ... } })`

### Our Encrypted Circuits:
All return single encrypted values, so we use the simple pattern.

**private_trade_callback.rs:**
```rust
#[arcium_callback(encrypted_ix = "private_trade")]
pub fn handler(
    ctx: Context<PrivateTradeCallback>,
    output: ComputationOutputs<PrivateTradeOutput>,
) -> Result<()> {
    let cfmm_state = match output {
        ComputationOutputs::Success(PrivateTradeOutput { field_0 }) => field_0,
        _ => return Err(ErrorCode::ComputationFailed.into()),
    };

    // Extract encrypted data
    let nonce = cfmm_state.nonce;
    let ciphertexts = cfmm_state.ciphertexts;  // This is an array

    // For CfmmState struct with (yes_reserves, no_reserves, new_commitment):
    // We need to understand how Arcium packs the struct into ciphertexts
    // Based on blackjack, it seems to create separate ciphertext entries

    // Update market state
    let market = &mut ctx.accounts.market;
    // ... update logic

    Ok(())
}
```

## 5. Account Structure Offsets (for Argument::Account)

From Market struct in state.rs:
```
discriminator: 8 bytes (offset 0)
authority: 32 bytes (offset 8)
question: 204 bytes (offset 40) [4 + 200]
end_time: 8 bytes (offset 244)
fee_bps: 2 bytes (offset 252)
batch_interval: 8 bytes (offset 254)
next_batch_clear: 8 bytes (offset 262)
resolver_quorum: 1 byte (offset 270)
resolver_count: 1 byte (offset 271)
attestation_count: 1 byte (offset 272)
collateral_vault: 32 bytes (offset 273)
fee_vault: 32 bytes (offset 305)
yes_mint: 32 bytes (offset 337)
no_mint: 32 bytes (offset 369)
cfmm_state_commitment: 32 bytes (offset 401) ← TARGET
yes_reserves: 8 bytes (offset 433) ← TARGET
no_reserves: 8 bytes (offset 441) ← TARGET
```

## 6. Missing Macro Imports

Need to ensure we're using the correct derive macros for output types. From blackjack, the output types seem to be auto-generated by Arcium's macro system.

## 7. Callback Account Structs

Need to follow blackjack pattern:
```rust
#[callback_accounts("encrypted_ix_name")]
#[derive(Accounts)]
pub struct CallbackName<'info> {
    pub arcium_program: Program<'info, Arcium>,
    #[account(
        address = derive_comp_def_pda!(COMP_DEF_OFFSET)
    )]
    pub comp_def_account: Account<'info, ComputationDefinitionAccount>,
    #[account(address = ::anchor_lang::solana_program::sysvar::instructions::ID)]
    /// CHECK: instructions_sysvar, checked by the account constraint
    pub instructions_sysvar: AccountInfo<'info>,
    #[account(mut)]
    pub market: Account<'info, Market>,
}
```

## Summary of Changes Needed:

### Files to Modify:
1. `submit_private_trade.rs` - Fix Arguments, add macro to struct
2. `submit_batch_order.rs` - Fix Arguments, add macro to struct
3. `submit_attestation.rs` - Fix Arguments, add macro to struct
4. `private_trade_callback.rs` - Fix output pattern, fix struct, add macro
5. `batch_clear_callback.rs` - Fix output pattern, fix struct, add macro
6. `resolve_market_callback.rs` - Fix output pattern, fix struct, add macro
7. `constants.rs` - Add account field offsets
8. `lib.rs` - ✅ Already fixed (#[arcium_program])

### Order of Implementation:
1. ✅ Fix program macro (DONE)
2. Add account field offset constants
3. Fix argument types in all invocation instructions
4. Add queue_computation_accounts macros to invocation structs
5. Fix callback output structures
6. Add callback_accounts macros to callback structs
7. Update callback account structs to match blackjack pattern
8. Build and test

---

**Note**: The exact callback output handling may need adjustment based on how Arcium generates types from our encrypted circuits. We may need to run `arcium build` to see the generated types.
